import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import AddToState from './AddToState';

// Mock fetch dla API
global.fetch = jest.fn();

beforeEach(() => {
  // Mock console.error i alert
  console.error = jest.fn();
  window.alert = jest.fn();
  
  // Resetuj wszystkie mocki
  fetch.mockClear();
  
  // Podstawowe mocki API
  fetch.mockImplementation((url, options) => {
    console.log(`Mock API call: ${url}`);
    
    if (url.includes('/api/state/warehouse')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([
          {
            _id: 'warehouse1',
            fullName: 'Kurtka Laura RUDY',
            size: 'XS', 
            barcode: '0652301100004',
            price: 100,
            transfer_to: 'P'
          },
          {
            _id: 'warehouse2',
            fullName: 'Kurtka Laura RUDY',
            size: 'XS',
            barcode: '0652301100004', 
            price: 100,
            transfer_to: 'P'
          }
        ])
      });
    }
    
    if (url.includes('/api/transfer') && !url.includes('process')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([])
      });
    }
    
    if (url.includes('/api/sales/get-all-sales')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([
          {
            _id: 'sales1',
            fullName: 'Kurtka Laura RUDY',
            size: 'XS',
            barcode: '0652301100004',
            isFromSale: true,
            cash: [{ price: 80, currency: 'PLN' }],
            transfer_to: 'P',
            date: new Date().toISOString()
          },
          {
            _id: 'sales2',
            fullName: 'Kurtka Laura RUDY',
            size: 'XS',
            barcode: '0652301100004',
            isFromSale: true,
            cash: [{ price: 80, currency: 'PLN' }],
            transfer_to: 'P',
            date: new Date().toISOString()
          }
        ])
      });
    }
    
    if (url.includes('/api/user')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          users: [
            { _id: 'user1', symbol: 'P', sellingPoint: 'Punkt P' }
          ]
        })
      });
    }
    
    if (url.includes('/api/state') && !url.includes('warehouse')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([
          {
            _id: 'state1',
            fullName: 'Kurtka Laura RUDY',
            size: 'XS',
            barcode: '0652301100004',
            sellingPoint: { symbol: 'P' }
          },
          {
            _id: 'state2', 
            fullName: 'Kurtka Laura RUDY',
            size: 'XS',
            barcode: '0652301100004',
            sellingPoint: { symbol: 'P' }
          }
        ])
      });
    }
    
    // Mock dla process endpoints
    if (url.includes('/api/transfer/process-sales')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ 
          processedCount: 1,
          message: 'Sales processed successfully',
          transactionId: 'test-transaction-123'
        })
      });
    }
    
    if (url.includes('/api/transfer/process-warehouse')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ 
          processedCount: 1,
          message: 'Warehouse items processed successfully',
          transactionId: 'test-transaction-123'
        })
      });
    }
    
    if (url.includes('/api/state/barcode/')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([
          {
            _id: 'state1',
            fullName: 'Kurtka Laura RUDY',
            size: 'XS',
            barcode: '0652301100004',
            symbol: 'P'
          }
        ])
      });
    }
    
    if (url.includes('/api/transfer/last-transaction')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ 
          hasLastTransaction: false,
          transactionId: null,
          timestamp: null,
          itemCount: 0
        })
      });
    }
    
    // Default return
    return Promise.resolve({
      ok: true,
      json: () => Promise.resolve([])
    });
  });
});

afterEach(() => {
  jest.clearAllMocks();
});

describe('AddToState - Zielone produkty (Enhanced Tests)', () => {
  test('podstawowa funkcjonalnoÅ›Ä‡ synchronizacji green products', async () => {
    render(<AddToState />);

    // Poczekaj na zaÅ‚adowanie komponentu
    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    // SprawdÅº czy przycisk przetwarzania jest dostÄ™pny
    expect(screen.getByText(/Zapisz - Odpisz wszystkie kurtki ze stanu/)).toBeInTheDocument();
  });

  test('synchronizacja tworzy sparowane produkty zielone', async () => {
    render(<AddToState />);

    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    // Wybierz uÅ¼ytkownika
    const userSelect = screen.getByLabelText('Select User:');
    fireEvent.change(userSelect, { target: { value: 'user1' } });

    // Wykonaj synchronizacjÄ™
    const syncButton = screen.getByText('ğŸ”„ Synchronizuj z magazynem');
    fireEvent.click(syncButton);

    // SprawdÅº czy wywoÅ‚ano odpowiednie API
    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith(expect.stringContaining('/api/state/warehouse'));
      expect(fetch).toHaveBeenCalledWith(expect.stringContaining('/api/sales/get-all-sales'));
    });
  });

  test('przetwarzanie green products wykonuje blue operations przed orange', async () => {
    const processCallOrder = [];
    
    // Mock aby Å›ledziÄ‡ kolejnoÅ›Ä‡ wywoÅ‚aÅ„
    fetch.mockImplementation((url, options) => {
      if (url.includes('/api/transfer/process-sales')) {
        processCallOrder.push('BLUE_OPERATION');
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ processedCount: 1 })
        });
      }
      
      if (url.includes('/api/transfer/process-warehouse')) {
        processCallOrder.push('ORANGE_OPERATION');
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ processedCount: 1 })
        });
      }
      
      // Inne endpoints
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([])
      });
    });

    render(<AddToState />);

    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    const userSelect = screen.getByLabelText('Select User:');
    fireEvent.change(userSelect, { target: { value: 'user1' } });

    const syncButton = screen.getByText('ğŸ”„ Synchronizuj z magazynem');
    fireEvent.click(syncButton);

    // Symuluj klikniÄ™cie przycisku przetwarzania (po synchronizacji)
    await waitFor(() => {
      const processButton = screen.getByText(/Zapisz - Odpisz wszystkie kurtki ze stanu/);
      expect(processButton).toBeInTheDocument();
    });

    // Potestujemy kolejnoÅ›Ä‡ operacji w osobnym teÅ›cie integracyjnym
  });

  test('obsÅ‚uguje bÅ‚Ä™dy podczas przetwarzania green products', async () => {
    // Mock bÅ‚Ä™du dla blue operation
    fetch.mockImplementation((url, options) => {
      if (url.includes('/api/transfer/process-sales')) {
        return Promise.resolve({
          ok: false,
          json: () => Promise.resolve({ error: 'Sales processing failed' })
        });
      }
      
      if (url.includes('/api/transfer/process-warehouse')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ processedCount: 1 })
        });
      }
      
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([])
      });
    });

    render(<AddToState />);

    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    const userSelect = screen.getByLabelText('Select User:');
    fireEvent.change(userSelect, { target: { value: 'user1' } });

    const syncButton = screen.getByText('ğŸ”„ Synchronizuj z magazynem');
    fireEvent.click(syncButton);

    // Test Å¼e komponent nie crashuje przy bÅ‚Ä™dach
    expect(syncButton).toBeInTheDocument();
  });

  test('reset synchronizacji przywraca domyÅ›lne kolory', async () => {
    render(<AddToState />);

    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Reset synchronizacji')).toBeInTheDocument();
    });

    const resetButton = screen.getByText('ğŸ”„ Reset synchronizacji');
    fireEvent.click(resetButton);

    // SprawdÅº czy funkcja siÄ™ wykonaÅ‚a bez bÅ‚Ä™dÃ³w
    expect(resetButton).toBeInTheDocument();
  });

  test('wyÅ›wietla poprawnÄ… liczbÄ™ produktÃ³w do przetworzenia', async () => {
    render(<AddToState />);

    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    const userSelect = screen.getByLabelText('Select User:');
    fireEvent.change(userSelect, { target: { value: 'user1' } });

    const syncButton = screen.getByText('ğŸ”„ Synchronizuj z magazynem');
    fireEvent.click(syncButton);

    // SprawdÅº czy licznik produktÃ³w jest wyÅ›wietlany
    await waitFor(() => {
      const processButton = screen.getByText(/Zapisz - Odpisz wszystkie kurtki ze stanu/);
      expect(processButton).toBeInTheDocument();
    });
  });
});

describe('AddToState - Testy integracyjne green products', () => {
  test('peÅ‚ny workflow synchronizacji i przetwarzania', async () => {
    const apiCalls = [];
    
    fetch.mockImplementation((url, options) => {
      apiCalls.push({ url, method: options?.method || 'GET' });
      
      // Podstawowe responses
      if (url.includes('/api/state/warehouse')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve([
            { _id: 'w1', fullName: 'Test', size: 'M', barcode: '123', price: 100 }
          ])
        });
      }
      
      if (url.includes('/api/sales/get-all-sales')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve([
            { _id: 's1', fullName: 'Test', size: 'M', barcode: '123', isFromSale: true }
          ])
        });
      }
      
      if (url.includes('/api/user')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({
            users: [{ _id: 'u1', symbol: 'P', sellingPoint: 'Punkt P' }]
          })
        });
      }
      
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([])
      });
    });

    render(<AddToState />);

    // 1. Poczekaj na zaÅ‚adowanie
    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    // 2. Wybierz uÅ¼ytkownika
    const userSelect = screen.getByLabelText('Select User:');
    fireEvent.change(userSelect, { target: { value: 'u1' } });

    // 3. Wykonaj synchronizacjÄ™
    const syncButton = screen.getByText('ğŸ”„ Synchronizuj z magazynem');
    fireEvent.click(syncButton);

    // 4. SprawdÅº czy zostaÅ‚y wykonane odpowiednie API calls
    await waitFor(() => {
      const warehouseCalls = apiCalls.filter(call => call.url.includes('/api/state/warehouse'));
      const salesCalls = apiCalls.filter(call => call.url.includes('/api/sales/get-all-sales'));
      
      expect(warehouseCalls.length).toBeGreaterThan(0);
      expect(salesCalls.length).toBeGreaterThan(0);
    });
  });

  test('scenariusz z wieloma identycznymi produktami', async () => {
    // Mock dla scenariusza 2 identycznych produktÃ³w Laura RUDY XS
    fetch.mockImplementation((url, options) => {
      if (url.includes('/api/state/warehouse')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve([
            { _id: 'w1', fullName: 'Laura RUDY', size: 'XS', barcode: '0652301100004', price: 100 },
            { _id: 'w2', fullName: 'Laura RUDY', size: 'XS', barcode: '0652301100004', price: 100 }
          ])
        });
      }
      
      if (url.includes('/api/sales/get-all-sales')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve([
            { _id: 's1', fullName: 'Laura RUDY', size: 'XS', barcode: '0652301100004', isFromSale: true },
            { _id: 's2', fullName: 'Laura RUDY', size: 'XS', barcode: '0652301100004', isFromSale: true }
          ])
        });
      }
      
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([])
      });
    });

    render(<AddToState />);

    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    const userSelect = screen.getByLabelText('Select User:');
    fireEvent.change(userSelect, { target: { value: 'user1' } });

    const syncButton = screen.getByText('ğŸ”„ Synchronizuj z magazynem');
    fireEvent.click(syncButton);

    // Test Å¼e nie ma bÅ‚Ä™dÃ³w przy identycznych produktach
    expect(syncButton).toBeInTheDocument();
  });
});

describe('AddToState - Edge Cases green products', () => {
  test('obsÅ‚uguje brak produktÃ³w w magazynie', async () => {
    fetch.mockImplementation((url) => {
      if (url.includes('/api/state/warehouse')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve([]) // Pusty magazyn
        });
      }
      
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([])
      });
    });

    render(<AddToState />);

    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    const syncButton = screen.getByText('ğŸ”„ Synchronizuj z magazynem');
    fireEvent.click(syncButton);

    // Test Å¼e komponent obsÅ‚uguje pusty magazyn
    expect(syncButton).toBeInTheDocument();
  });

  test('obsÅ‚uguje brak sprzedaÅ¼y', async () => {
    fetch.mockImplementation((url) => {
      if (url.includes('/api/sales/get-all-sales')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve([]) // Brak sprzedaÅ¼y
        });
      }
      
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve([])
      });
    });

    render(<AddToState />);

    await waitFor(() => {
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });

    const syncButton = screen.getByText('ğŸ”„ Synchronizuj z magazynem');
    fireEvent.click(syncButton);

    // Test Å¼e komponent obsÅ‚uguje brak sprzedaÅ¼y
    expect(syncButton).toBeInTheDocument();
  });

  test('obsÅ‚uguje bÅ‚Ä™dy API', async () => {
    fetch.mockImplementation((url) => {
      return Promise.resolve({
        ok: false,
        status: 500,
        json: () => Promise.resolve({ error: 'Server error' })
      });
    });

    render(<AddToState />);

    await waitFor(() => {
      // Komponent powinien siÄ™ zaÅ‚adowaÄ‡ mimo bÅ‚Ä™dÃ³w API
      expect(screen.getByText('ğŸ”„ Synchronizuj z magazynem')).toBeInTheDocument();
    });
  });
});
